-- liquibase formatted sql
-- changeset HMA:315a54b3c0cd2ccf3a606dec1e183acc845bc398 stripComments:false logicalFilePath:package_bodies\tapi_api_configuration.sql
-- sqlcl_snapshot src/database/hma/package_bodies/tapi_api_configuration.pkb:null:315a54b3c0cd2ccf3a606dec1e183acc845bc398:create

create or replace package body hma.tapi_api_configuration is 

   /**
   * TAPI_API_CONFIGURATION
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 2024-10-12
   */

    --Global logger scope
    gc_scope_prefix constant varchar2(31) := lower($$plsql_unit)
                                             || '.';

   --GLOBAL_PRIVATE_CURSORS
   --By PK
    cursor api_configuration_cur (
        p_config_name in api_configuration.config_name%type
    ) is
    select
        config_name,
        config_value,
        tapi_api_configuration.hash(config_name),
        rowid
    from
        api_configuration
    where
        config_name = api_configuration_cur.p_config_name
    for update;

    --By Rowid
    cursor api_configuration_rowid_cur (
        p_rowid in varchar2
    ) is
    select
        config_name,
        config_value,
        tapi_api_configuration.hash(config_name),
        rowid
    from
        api_configuration
    where
        rowid = p_rowid
    for update;

    function hash (
        p_config_name in api_configuration.config_name%type
    ) return varchar2 is

        l_scope       logger_logs.scope%type := gc_scope_prefix || 'hash';
        l_params      logger.tab_param;
        l_retval      hash_t;
        l_string      clob;
        l_date_format varchar2(64);
    begin
        logger.append_param(l_params, 'p_config_name', p_config_name);
        logger.log('START', l_scope, null, l_params);
        logger.log('Getting row data into one string', l_scope);

     --Get actual NLS_DATE_FORMAT
        select
            value
        into l_date_format
        from
            v$nls_parameters
        where
            parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
        execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';
        select
            config_name || config_value
        into l_string
        from
            api_configuration
        where
            config_name = hash.p_config_name;

      --Restore NLS_DATE_FORMAT to default
        execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT='''
                          || l_date_format
                          || '''';
        logger.log('Converting into SHA1 hash', l_scope);
        l_retval := dbms_crypto.hash(l_string, dbms_crypto.hash_sh1);
        logger.log('END', l_scope);
        return l_retval;
    exception
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end hash;

    function hash_rowid (
        p_rowid in varchar2
    ) return varchar2 is

        l_scope       logger_logs.scope%type := gc_scope_prefix || 'hash_rowid';
        l_params      logger.tab_param;
        l_retval      hash_t;
        l_string      clob;
        l_date_format varchar2(64);
    begin
        logger.append_param(l_params, 'p_rowid', p_rowid);
        logger.log('START', l_scope, null, l_params);
        logger.log('Getting row data into one string', l_scope);

      --Get actual NLS_DATE_FORMAT
        select
            value
        into l_date_format
        from
            v$nls_parameters
        where
            parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
        execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';
        select
            config_name || config_value
        into l_string
        from
            api_configuration
        where
            rowid = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
        execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT='''
                          || l_date_format
                          || '''';
        logger.log('Converting into SHA1 hash', l_scope);
        l_retval := dbms_crypto.hash(l_string, dbms_crypto.hash_sh1);
        logger.log('END', l_scope);
        return l_retval;
    exception
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end hash_rowid;

    function rt (
        p_config_name in api_configuration.config_name%type
    ) return api_configuration_rt
        result_cache
    is

        l_scope                 logger_logs.scope%type := gc_scope_prefix || 'rt';
        l_params                logger.tab_param;
        l_api_configuration_rec api_configuration_rt;
    begin
        logger.append_param(l_params, 'p_config_name', p_config_name);
        logger.log('START', l_scope, null, l_params);
        logger.log('Populating record type from DB', l_scope);
        select
            a.*,
            tapi_api_configuration.hash(config_name),
            rowid
        into l_api_configuration_rec
        from
            api_configuration a
        where
            config_name = rt.p_config_name;

        logger.log('END', l_scope);
        return l_api_configuration_rec;
    exception
        when no_data_found then
            return null;
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end rt;

    function rt_for_update (
        p_config_name in api_configuration.config_name%type
    ) return api_configuration_rt
        result_cache
    is

        l_scope                 logger_logs.scope%type := gc_scope_prefix || 'rt_for_update';
        l_params                logger.tab_param;
        l_api_configuration_rec api_configuration_rt;
    begin
        logger.append_param(l_params, 'p_config_name', p_config_name);
        logger.log('START', l_scope, null, l_params);
        logger.log('Populating record type from DB', l_scope);
        select
            a.*,
            tapi_api_configuration.hash(config_name),
            rowid
        into l_api_configuration_rec
        from
            api_configuration a
        where
            config_name = rt_for_update.p_config_name
        for update;

        logger.log('END', l_scope);
        return l_api_configuration_rec;
    exception
        when no_data_found then
            return null;
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end rt_for_update;

    function tt (
        p_config_name in api_configuration.config_name%type default null
    ) return api_configuration_tt
        pipelined
    is

        l_scope                 logger_logs.scope%type := gc_scope_prefix || 'tt';
        l_params                logger.tab_param;
        l_api_configuration_rec api_configuration_rt;
    begin
        logger.append_param(l_params, 'p_config_name', tt.p_config_name);
        logger.log('START', l_scope, null, l_params);
        logger.log('Populating record type from DB', l_scope);
        for c1 in (
            select
                a.*,
                rowid
            from
                api_configuration a
            where
                config_name = nvl(tt.p_config_name, config_name)
        ) loop
            l_api_configuration_rec.config_name := c1.config_name;
            l_api_configuration_rec.config_value := c1.config_value;
            l_api_configuration_rec.hash := tapi_api_configuration.hash(c1.config_name);
            l_api_configuration_rec.row_id := c1.rowid;
            pipe row ( l_api_configuration_rec );
        end loop;

        logger.log('END', l_scope);
        return;
    exception
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end tt;

    procedure ins (
        p_api_configuration_rec in out api_configuration_rt
    ) is

        l_scope   logger_logs.scope%type := gc_scope_prefix || 'ins';
        l_params  logger.tab_param;
        l_rowtype api_configuration%rowtype;
    begin
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_name',
                            ins.p_api_configuration_rec.config_name);
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_value',
                            ins.p_api_configuration_rec.config_value);
        logger.log('START', l_scope, null, l_params);
        logger.log('Inserting data', l_scope);
        l_rowtype.config_name := ins.p_api_configuration_rec.config_name;
        l_rowtype.config_value := ins.p_api_configuration_rec.config_value;
        insert into api_configuration values l_rowtype returning config_name,
                                                                 config_value into l_rowtype;

        ins.p_api_configuration_rec.config_name := l_rowtype.config_name;
        ins.p_api_configuration_rec.config_value := l_rowtype.config_value;
        logger.log('END', l_scope);
    exception
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end ins;

    procedure upd (
        p_api_configuration_rec in api_configuration_rt,
        p_ignore_nulls          in boolean := false
    ) is
        l_scope  logger_logs.scope%type := gc_scope_prefix || 'upd';
        l_params logger.tab_param;
    begin
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_name',
                            upd.p_api_configuration_rec.config_name);
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_value',
                            upd.p_api_configuration_rec.config_value);
        logger.log('START', l_scope, null, l_params);
        logger.log('Updating table', l_scope);
        if nvl(p_ignore_nulls, false) then
            update api_configuration
            set
                config_name = nvl(p_api_configuration_rec.config_name, config_name),
                config_value = nvl(p_api_configuration_rec.config_value, config_value)
            where
                config_name = upd.p_api_configuration_rec.config_name;

        else
            update api_configuration
            set
                config_name = p_api_configuration_rec.config_name,
                config_value = p_api_configuration_rec.config_value
            where
                config_name = upd.p_api_configuration_rec.config_name;

        end if;

        if sql%rowcount != 1 then
            raise e_upd_failed;
        end if;
        logger.log('END', l_scope);
    exception
        when e_upd_failed then
            raise_application_error(-20000, 'No rows were updated. The update failed.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end upd;

    procedure upd_rowid (
        p_api_configuration_rec in api_configuration_rt,
        p_ignore_nulls          in boolean := false
    ) is
        l_scope  logger_logs.scope%type := gc_scope_prefix || 'upd_rowid';
        l_params logger.tab_param;
    begin
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_name',
                            upd_rowid.p_api_configuration_rec.config_name);
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_value',
                            upd_rowid.p_api_configuration_rec.config_value);
        logger.log('START', l_scope, null, l_params);
        logger.log('Updating table', l_scope);
        if nvl(p_ignore_nulls, false) then
            update api_configuration
            set
                config_name = nvl(p_api_configuration_rec.config_name, config_name),
                config_value = nvl(p_api_configuration_rec.config_value, config_value)
            where
                rowid = p_api_configuration_rec.row_id;

        else
            update api_configuration
            set
                config_name = p_api_configuration_rec.config_name,
                config_value = p_api_configuration_rec.config_value
            where
                rowid = p_api_configuration_rec.row_id;

        end if;

        if sql%rowcount != 1 then
            raise e_upd_failed;
        end if;
        logger.log('END', l_scope);
    exception
        when e_upd_failed then
            raise_application_error(-20000, 'No rows were updated. The update failed.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end upd_rowid;

    procedure web_upd (
        p_api_configuration_rec in api_configuration_rt,
        p_ignore_nulls          in boolean := false
    ) is

        l_scope                 logger_logs.scope%type := gc_scope_prefix || 'web_upd';
        l_params                logger.tab_param;
        l_api_configuration_rec api_configuration_rt;
    begin
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_name',
                            web_upd.p_api_configuration_rec.config_name);
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_value',
                            web_upd.p_api_configuration_rec.config_value);
        logger.log('START', l_scope, null, l_params);
        logger.log('Updating table', l_scope);
        open api_configuration_cur(web_upd.p_api_configuration_rec.config_name);
        fetch api_configuration_cur into l_api_configuration_rec;
        if api_configuration_cur%notfound then
            close api_configuration_cur;
            raise e_row_missing;
        else
            if p_api_configuration_rec.hash != l_api_configuration_rec.hash then
                close api_configuration_cur;
                raise e_ol_check_failed;
            else
                if nvl(p_ignore_nulls, false) then
                    update api_configuration
                    set
                        config_name = nvl(p_api_configuration_rec.config_name, config_name),
                        config_value = nvl(p_api_configuration_rec.config_value, config_value)
                    where
                        current of api_configuration_cur;

                else
                    update api_configuration
                    set
                        config_name = p_api_configuration_rec.config_name,
                        config_value = p_api_configuration_rec.config_value
                    where
                        current of api_configuration_cur;

                end if;

                close api_configuration_cur;
            end if;
        end if;

        logger.log('END', l_scope);
    exception
        when e_ol_check_failed then
            raise_application_error(-20000, 'Current version of data in database has changed since last page refresh.');
        when e_row_missing then
            raise_application_error(-20000, 'Update operation failed because the row is no longer in the database.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end web_upd;

    procedure web_upd_rowid (
        p_api_configuration_rec in api_configuration_rt,
        p_ignore_nulls          in boolean := false
    ) is

        l_scope                 logger_logs.scope%type := gc_scope_prefix || 'web_upd_rowid';
        l_params                logger.tab_param;
        l_api_configuration_rec api_configuration_rt;
    begin
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_name',
                            web_upd_rowid.p_api_configuration_rec.config_name);
        logger.append_param(l_params,
                            'p_api_configuration_rec.config_value',
                            web_upd_rowid.p_api_configuration_rec.config_value);
        logger.log('START', l_scope, null, l_params);
        logger.log('Updating table', l_scope);
        open api_configuration_rowid_cur(web_upd_rowid.p_api_configuration_rec.row_id);
        fetch api_configuration_rowid_cur into l_api_configuration_rec;
        if api_configuration_rowid_cur%notfound then
            close api_configuration_rowid_cur;
            raise e_row_missing;
        else
            if web_upd_rowid.p_api_configuration_rec.hash != l_api_configuration_rec.hash then
                close api_configuration_rowid_cur;
                raise e_ol_check_failed;
            else
                if nvl(web_upd_rowid.p_ignore_nulls, false) then
                    update api_configuration
                    set
                        config_name = nvl(p_api_configuration_rec.config_name, config_name),
                        config_value = nvl(p_api_configuration_rec.config_value, config_value)
                    where
                        current of api_configuration_rowid_cur;

                else
                    update api_configuration
                    set
                        config_name = p_api_configuration_rec.config_name,
                        config_value = p_api_configuration_rec.config_value
                    where
                        current of api_configuration_rowid_cur;

                end if;

                close api_configuration_rowid_cur;
            end if;
        end if;

        logger.log('END', l_scope);
    exception
        when e_ol_check_failed then
            raise_application_error(-20000, 'Current version of data in database has changed since last page refresh.');
        when e_row_missing then
            raise_application_error(-20000, 'Update operation failed because the row is no longer in the database.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end web_upd_rowid;

    procedure del (
        p_config_name in api_configuration.config_name%type
    ) is
        l_scope  logger_logs.scope%type := gc_scope_prefix || 'del';
        l_params logger.tab_param;
    begin
        logger.append_param(l_params, 'p_config_name', del.p_config_name);
        logger.log('START', l_scope, null, l_params);
        logger.log('Deleting record', l_scope);
        delete from api_configuration
        where
            config_name = del.p_config_name;

        if sql%rowcount != 1 then
            raise e_del_failed;
        end if;
        logger.log('END', l_scope);
    exception
        when e_del_failed then
            raise_application_error(-20000, 'No rows were deleted. The delete failed.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end del;

    procedure del_rowid (
        p_rowid in varchar2
    ) is
        l_scope  logger_logs.scope%type := gc_scope_prefix || 'del_rowid';
        l_params logger.tab_param;
    begin
        logger.append_param(l_params, 'p_rowid', del_rowid.p_rowid);
        logger.log('START', l_scope, null, l_params);
        logger.log('Deleting record', l_scope);
        delete from api_configuration
        where
            rowid = del_rowid.p_rowid;

        if sql%rowcount != 1 then
            raise e_del_failed;
        end if;
        logger.log('END', l_scope);
    exception
        when e_del_failed then
            raise_application_error(-20000, 'No rows were deleted. The delete failed.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end del_rowid;

    procedure web_del (
        p_config_name in api_configuration.config_name%type,
        p_hash        in varchar2
    ) is

        l_scope                 logger_logs.scope%type := gc_scope_prefix || 'web_del';
        l_params                logger.tab_param;
        l_api_configuration_rec api_configuration_rt;
    begin
        logger.append_param(l_params, 'p_config_name', web_del.p_config_name);
        logger.log('START', l_scope, null, l_params);
        logger.log('Deleting record', l_scope);
        open api_configuration_cur(web_del.p_config_name);
        fetch api_configuration_cur into l_api_configuration_rec;
        if api_configuration_cur%notfound then
            close api_configuration_cur;
            raise e_row_missing;
        else
            if web_del.p_hash != l_api_configuration_rec.hash then
                close api_configuration_cur;
                raise e_ol_check_failed;
            else
                delete from api_configuration
                where
                    current of api_configuration_cur;

                close api_configuration_cur;
            end if;
        end if;

        logger.log('END', l_scope);
    exception
        when e_ol_check_failed then
            raise_application_error(-20000, 'Current version of data in database has changed since last page refresh.');
        when e_row_missing then
            raise_application_error(-20000, 'Delete operation failed because the row is no longer in the database.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end web_del;

    procedure web_del_rowid (
        p_rowid in varchar2,
        p_hash  in varchar2
    ) is

        l_scope                 logger_logs.scope%type := gc_scope_prefix || 'web_del_rowid';
        l_params                logger.tab_param;
        l_api_configuration_rec api_configuration_rt;
    begin
        logger.append_param(l_params, 'p_rowid', web_del_rowid.p_rowid);
        logger.log('START', l_scope, null, l_params);
        logger.log('Deleting record', l_scope);
        open api_configuration_rowid_cur(web_del_rowid.p_rowid);
        fetch api_configuration_rowid_cur into l_api_configuration_rec;
        if api_configuration_rowid_cur%notfound then
            close api_configuration_rowid_cur;
            raise e_row_missing;
        else
            if web_del_rowid.p_hash != l_api_configuration_rec.hash then
                close api_configuration_rowid_cur;
                raise e_ol_check_failed;
            else
                delete from api_configuration
                where
                    current of api_configuration_rowid_cur;

                close api_configuration_rowid_cur;
            end if;
        end if;

        logger.log('END', l_scope);
    exception
        when e_ol_check_failed then
            raise_application_error(-20000, 'Current version of data in database has changed since last page refresh.');
        when e_row_missing then
            raise_application_error(-20000, 'Delete operation failed because the row is no longer in the database.');
        when others then
            logger.log_error('Unhandled Exception', l_scope, null, l_params);
            raise;
    end web_del_rowid;

end tapi_api_configuration;
/