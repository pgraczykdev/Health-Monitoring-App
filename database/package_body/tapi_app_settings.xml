<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog 
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xmlns:n0="http://www.oracle.com/xml/ns/dbchangelog-ext" 
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog 
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
 <changeSet id="1" author="pg">
     <n0:createOraclePackageBody 
     objectName="tapi_app_settings" 
     objectType="PACKAGE_BODY" 
     ownerName="HMA"  
     replaceIfExists="true" >
        <n0:source><![CDATA[
create or replace package body tapi_app_settings is

   /**
   * TAPI_APP_SETTINGS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 2024-10-13
   */

    --Global logger scope
   gc_scope_prefix constant varchar2(31) := LOWER($$plsql_unit)
                                            || '.';

   --GLOBAL_PRIVATE_CURSORS
   --By PK
   cursor app_settings_cur (
      p_setting_name in app_settings.setting_name%type
   ) is
   select setting_name,
          setting_value,
          tapi_app_settings.hash(setting_name),
          rowid
     from app_settings
    where setting_name = app_settings_cur.p_setting_name
   for update;

    --By Rowid
   cursor app_settings_rowid_cur (
      p_rowid in varchar2
   ) is
   select setting_name,
          setting_value,
          tapi_app_settings.hash(setting_name),
          rowid
     from app_settings
    where rowid = p_rowid
   for update;


   function hash (
      p_setting_name in app_settings.setting_name%type
   ) return varchar2 is
      l_scope       logger_logs.scope%type := gc_scope_prefix || 'hash';
      l_params      logger.tab_param;
      l_retval      hash_t;
      l_string      clob;
      l_date_format varchar2(64);
   begin
      logger.append_param(
                         l_params,
                         'p_setting_name',
                         p_setting_name
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Getting row data into one string',
                l_scope
      );

     --Get actual NLS_DATE_FORMAT
      select VALUE
        into l_date_format
        from v$nls_parameters
       where parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';
      select setting_name || setting_value
        into l_string
        from app_settings
       where setting_name = hash.p_setting_name;

      --Restore NLS_DATE_FORMAT to default
      execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT='''
                        || l_date_format
                        || '''';
      logger.LOG(
                'Converting into SHA1 hash',
                l_scope
      );
      l_retval := DBMS_CRYPTO.hash(
                                  l_string,
                                  DBMS_CRYPTO.hash_sh1
                  );
      logger.LOG(
                'END',
                l_scope
      );
      return l_retval;
   exception
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end hash;

   function hash_rowid (
      p_rowid in varchar2
   ) return varchar2 is
      l_scope       logger_logs.scope%type := gc_scope_prefix || 'hash_rowid';
      l_params      logger.tab_param;
      l_retval      hash_t;
      l_string      clob;
      l_date_format varchar2(64);
   begin
      logger.append_param(
                         l_params,
                         'p_rowid',
                         p_rowid
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Getting row data into one string',
                l_scope
      );

      --Get actual NLS_DATE_FORMAT
      select VALUE
        into l_date_format
        from v$nls_parameters
       where parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';
      select setting_name || setting_value
        into l_string
        from app_settings
       where rowid = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT='''
                        || l_date_format
                        || '''';
      logger.LOG(
                'Converting into SHA1 hash',
                l_scope
      );
      l_retval := DBMS_CRYPTO.hash(
                                  l_string,
                                  DBMS_CRYPTO.hash_sh1
                  );
      logger.LOG(
                'END',
                l_scope
      );
      return l_retval;
   exception
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end hash_rowid;

   function rt (
      p_setting_name in app_settings.setting_name%type
   ) return app_settings_rt
      result_cache
   is
      l_scope            logger_logs.scope%type := gc_scope_prefix || 'rt';
      l_params           logger.tab_param;
      l_app_settings_rec app_settings_rt;
   begin
      logger.append_param(
                         l_params,
                         'p_setting_name',
                         p_setting_name
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Populating record type from DB',
                l_scope
      );
      select a.*,
             tapi_app_settings.hash(setting_name),
             rowid
        into l_app_settings_rec
        from app_settings a
       where setting_name = rt.p_setting_name;

      logger.LOG(
                'END',
                l_scope
      );
      return l_app_settings_rec;
   exception
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end rt;

   function rt_for_update (
      p_setting_name in app_settings.setting_name%type
   ) return app_settings_rt
      result_cache
   is
      l_scope            logger_logs.scope%type := gc_scope_prefix || 'rt_for_update';
      l_params           logger.tab_param;
      l_app_settings_rec app_settings_rt;
   begin
      logger.append_param(
                         l_params,
                         'p_setting_name',
                         p_setting_name
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Populating record type from DB',
                l_scope
      );
      select a.*,
             tapi_app_settings.hash(setting_name),
             rowid
        into l_app_settings_rec
        from app_settings a
       where setting_name = rt_for_update.p_setting_name
      for update;

      logger.LOG(
                'END',
                l_scope
      );
      return l_app_settings_rec;
   exception
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end rt_for_update;

   function tt (
      p_setting_name in app_settings.setting_name%type default null
   ) return app_settings_tt
      pipelined
   is
      l_scope            logger_logs.scope%type := gc_scope_prefix || 'tt';
      l_params           logger.tab_param;
      l_app_settings_rec app_settings_rt;
   begin
      logger.append_param(
                         l_params,
                         'p_setting_name',
                         tt.p_setting_name
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Populating record type from DB',
                l_scope
      );
      for c1 in (
         select a.*,
                rowid
           from app_settings a
          where setting_name = NVL(
            tt.p_setting_name,
            setting_name
         )
      ) loop
         l_app_settings_rec.setting_name  := c1.setting_name;
         l_app_settings_rec.setting_value := c1.setting_value;
         l_app_settings_rec.hash          := tapi_app_settings.hash(c1.setting_name);
         l_app_settings_rec.row_id        := c1.ROWID;
         pipe row ( l_app_settings_rec );
      end loop;

      logger.LOG(
                'END',
                l_scope
      );
      return;
   exception
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end tt;


   procedure ins (
      p_app_settings_rec in out app_settings_rt
   ) is
      l_scope   logger_logs.scope%type := gc_scope_prefix || 'ins';
      l_params  logger.tab_param;
      l_rowtype app_settings%ROWTYPE;
   begin
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_name',
                         ins.p_app_settings_rec.setting_name
      );
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_value',
                         ins.p_app_settings_rec.setting_value
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Inserting data',
                l_scope
      );
      l_rowtype.setting_name               := ins.p_app_settings_rec.setting_name;
      l_rowtype.setting_value              := ins.p_app_settings_rec.setting_value;
      insert into app_settings values l_rowtype returning setting_name,
                                                          setting_value into l_rowtype;

      ins.p_app_settings_rec.setting_name  := l_rowtype.setting_name;
      ins.p_app_settings_rec.setting_value := l_rowtype.setting_value;
      logger.LOG(
                'END',
                l_scope
      );
   exception
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end ins;

   procedure upd (
      p_app_settings_rec in app_settings_rt,
      p_ignore_nulls     in boolean := false
   ) is
      l_scope  logger_logs.scope%type := gc_scope_prefix || 'upd';
      l_params logger.tab_param;
   begin
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_name',
                         upd.p_app_settings_rec.setting_name
      );
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_value',
                         upd.p_app_settings_rec.setting_value
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Updating table',
                l_scope
      );
      if NVL(
            p_ignore_nulls,
            false
         ) then
         update app_settings
            set setting_name = NVL(
            p_app_settings_rec.setting_name,
            setting_name
         ),
                setting_value = NVL(
                   p_app_settings_rec.setting_value,
                   setting_value
                )
          where setting_name = upd.p_app_settings_rec.setting_name;
      else
         update app_settings
            set setting_name = p_app_settings_rec.setting_name,
                setting_value = p_app_settings_rec.setting_value
          where setting_name = upd.p_app_settings_rec.setting_name;
      end if;

      if sql%ROWCOUNT != 1 then
         raise e_upd_failed;
      end if;
      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_upd_failed then
         raise_application_error(
                                -20000,
                                'No rows were updated. The update failed.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end upd;


   procedure upd_rowid (
      p_app_settings_rec in app_settings_rt,
      p_ignore_nulls     in boolean := false
   ) is
      l_scope  logger_logs.scope%type := gc_scope_prefix || 'upd_rowid';
      l_params logger.tab_param;
   begin
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_name',
                         upd_rowid.p_app_settings_rec.setting_name
      );
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_value',
                         upd_rowid.p_app_settings_rec.setting_value
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Updating table',
                l_scope
      );
      if NVL(
            p_ignore_nulls,
            false
         ) then
         update app_settings
            set setting_name = NVL(
            p_app_settings_rec.setting_name,
            setting_name
         ),
                setting_value = NVL(
                   p_app_settings_rec.setting_value,
                   setting_value
                )
          where rowid = p_app_settings_rec.row_id;
      else
         update app_settings
            set setting_name = p_app_settings_rec.setting_name,
                setting_value = p_app_settings_rec.setting_value
          where rowid = p_app_settings_rec.row_id;
      end if;

      if sql%ROWCOUNT != 1 then
         raise e_upd_failed;
      end if;
      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_upd_failed then
         raise_application_error(
                                -20000,
                                'No rows were updated. The update failed.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end upd_rowid;

   procedure web_upd (
      p_app_settings_rec in app_settings_rt,
      p_ignore_nulls     in boolean := false
   ) is
      l_scope            logger_logs.scope%type := gc_scope_prefix || 'web_upd';
      l_params           logger.tab_param;
      l_app_settings_rec app_settings_rt;
   begin
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_name',
                         web_upd.p_app_settings_rec.setting_name
      );
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_value',
                         web_upd.p_app_settings_rec.setting_value
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Updating table',
                l_scope
      );
      open app_settings_cur(web_upd.p_app_settings_rec.setting_name);
      fetch app_settings_cur into l_app_settings_rec;
      if app_settings_cur%NOTFOUND then
         close app_settings_cur;
         raise e_row_missing;
      else
         if p_app_settings_rec.hash != l_app_settings_rec.hash then
            close app_settings_cur;
            raise e_ol_check_failed;
         else
            if NVL(
                  p_ignore_nulls,
                  false
               ) then
               update app_settings
                  set setting_name = NVL(
                  p_app_settings_rec.setting_name,
                  setting_name
               ),
                      setting_value = NVL(
                         p_app_settings_rec.setting_value,
                         setting_value
                      )
                where current of app_settings_cur;
            else
               update app_settings
                  set setting_name = p_app_settings_rec.setting_name,
                      setting_value = p_app_settings_rec.setting_value
                where current of app_settings_cur;
            end if;

            close app_settings_cur;
         end if;
      end if;

      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_ol_check_failed then
         raise_application_error(
                                -20000,
                                'Current version of data in database has changed since last page refresh.'
         );
      when e_row_missing then
         raise_application_error(
                                -20000,
                                'Update operation failed because the row is no longer in the database.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end web_upd;

   procedure web_upd_rowid (
      p_app_settings_rec in app_settings_rt,
      p_ignore_nulls     in boolean := false
   ) is
      l_scope            logger_logs.scope%type := gc_scope_prefix || 'web_upd_rowid';
      l_params           logger.tab_param;
      l_app_settings_rec app_settings_rt;
   begin
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_name',
                         web_upd_rowid.p_app_settings_rec.setting_name
      );
      logger.append_param(
                         l_params,
                         'p_app_settings_rec.setting_value',
                         web_upd_rowid.p_app_settings_rec.setting_value
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Updating table',
                l_scope
      );
      open app_settings_rowid_cur(web_upd_rowid.p_app_settings_rec.row_id);
      fetch app_settings_rowid_cur into l_app_settings_rec;
      if app_settings_rowid_cur%NOTFOUND then
         close app_settings_rowid_cur;
         raise e_row_missing;
      else
         if web_upd_rowid.p_app_settings_rec.hash != l_app_settings_rec.hash then
            close app_settings_rowid_cur;
            raise e_ol_check_failed;
         else
            if NVL(
                  web_upd_rowid.p_ignore_nulls,
                  false
               ) then
               update app_settings
                  set setting_name = NVL(
                  p_app_settings_rec.setting_name,
                  setting_name
               ),
                      setting_value = NVL(
                         p_app_settings_rec.setting_value,
                         setting_value
                      )
                where current of app_settings_rowid_cur;
            else
               update app_settings
                  set setting_name = p_app_settings_rec.setting_name,
                      setting_value = p_app_settings_rec.setting_value
                where current of app_settings_rowid_cur;
            end if;

            close app_settings_rowid_cur;
         end if;
      end if;

      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_ol_check_failed then
         raise_application_error(
                                -20000,
                                'Current version of data in database has changed since last page refresh.'
         );
      when e_row_missing then
         raise_application_error(
                                -20000,
                                'Update operation failed because the row is no longer in the database.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end web_upd_rowid;

   procedure del (
      p_setting_name in app_settings.setting_name%type
   ) is
      l_scope  logger_logs.scope%type := gc_scope_prefix || 'del';
      l_params logger.tab_param;
   begin
      logger.append_param(
                         l_params,
                         'p_setting_name',
                         del.p_setting_name
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Deleting record',
                l_scope
      );
      delete from app_settings
       where setting_name = del.p_setting_name;

      if sql%ROWCOUNT != 1 then
         raise e_del_failed;
      end if;
      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_del_failed then
         raise_application_error(
                                -20000,
                                'No rows were deleted. The delete failed.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end del;

   procedure del_rowid (
      p_rowid in varchar2
   ) is
      l_scope  logger_logs.scope%type := gc_scope_prefix || 'del_rowid';
      l_params logger.tab_param;
   begin
      logger.append_param(
                         l_params,
                         'p_rowid',
                         del_rowid.p_rowid
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Deleting record',
                l_scope
      );
      delete from app_settings
       where rowid = del_rowid.p_rowid;

      if sql%ROWCOUNT != 1 then
         raise e_del_failed;
      end if;
      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_del_failed then
         raise_application_error(
                                -20000,
                                'No rows were deleted. The delete failed.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end del_rowid;

   procedure web_del (
      p_setting_name in app_settings.setting_name%type,
      p_hash         in varchar2
   ) is
      l_scope            logger_logs.scope%type := gc_scope_prefix || 'web_del';
      l_params           logger.tab_param;
      l_app_settings_rec app_settings_rt;
   begin
      logger.append_param(
                         l_params,
                         'p_setting_name',
                         web_del.p_setting_name
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Deleting record',
                l_scope
      );
      open app_settings_cur(web_del.p_setting_name);
      fetch app_settings_cur into l_app_settings_rec;
      if app_settings_cur%NOTFOUND then
         close app_settings_cur;
         raise e_row_missing;
      else
         if web_del.p_hash != l_app_settings_rec.hash then
            close app_settings_cur;
            raise e_ol_check_failed;
         else
            delete from app_settings
             where current of app_settings_cur;

            close app_settings_cur;
         end if;
      end if;


      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_ol_check_failed then
         raise_application_error(
                                -20000,
                                'Current version of data in database has changed since last page refresh.'
         );
      when e_row_missing then
         raise_application_error(
                                -20000,
                                'Delete operation failed because the row is no longer in the database.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end web_del;

   procedure web_del_rowid (
      p_rowid in varchar2,
      p_hash  in varchar2
   ) is
      l_scope            logger_logs.scope%type := gc_scope_prefix || 'web_del_rowid';
      l_params           logger.tab_param;
      l_app_settings_rec app_settings_rt;
   begin
      logger.append_param(
                         l_params,
                         'p_rowid',
                         web_del_rowid.p_rowid
      );
      logger.LOG(
                'START',
                l_scope,
                null,
                l_params
      );
      logger.LOG(
                'Deleting record',
                l_scope
      );
      open app_settings_rowid_cur(web_del_rowid.p_rowid);
      fetch app_settings_rowid_cur into l_app_settings_rec;
      if app_settings_rowid_cur%NOTFOUND then
         close app_settings_rowid_cur;
         raise e_row_missing;
      else
         if web_del_rowid.p_hash != l_app_settings_rec.hash then
            close app_settings_rowid_cur;
            raise e_ol_check_failed;
         else
            delete from app_settings
             where current of app_settings_rowid_cur;

            close app_settings_rowid_cur;
         end if;
      end if;

      logger.LOG(
                'END',
                l_scope
      );
   exception
      when e_ol_check_failed then
         raise_application_error(
                                -20000,
                                'Current version of data in database has changed since last page refresh.'
         );
      when e_row_missing then
         raise_application_error(
                                -20000,
                                'Delete operation failed because the row is no longer in the database.'
         );
      when others then
         logger.log_error(
                         'Unhandled Exception',
                         l_scope,
                         null,
                         l_params
         );
         raise;
   end web_del_rowid;

end tapi_app_settings;

           ]]></n0:source>
        </n0:createOraclePackageBody>
    </changeSet>
</databaseChangeLog> 
